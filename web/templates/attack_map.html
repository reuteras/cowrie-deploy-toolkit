{% extends "base.html" %}

{% block title %}Attack Map - Cowrie Honeypot{% endblock %}

{% block head %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
{% endblock %}

{% block content %}
<div class="attack-map-page">
    <div class="page-header">
        <h1>üéØ Live Attack Visualization</h1>
        <div class="header-actions">
            {% if available_sources %}
            <label>Source:</label>
            <select id="source-filter" onchange="updateFilters()">
                <option value="" {% if not source_filter %}selected{% endif %}>All Honeypots</option>
                {% for source_name in available_sources %}
                <option value="{{ source_name }}" {% if source_filter == source_name %}selected{% endif %}>{{ source_name }}</option>
                {% endfor %}
            </select>
            {% endif %}
            <select id="hours-selector" onchange="updateFilters()" disabled>
                <option value="1" {% if hours == 1 %}selected{% endif %}>Last Hour</option>
                <option value="6" {% if hours == 6 %}selected{% endif %}>Last 6 Hours</option>
                <option value="24" {% if hours == 24 %}selected{% endif %}>Last 24 Hours</option>
                <option value="168" {% if hours == 168 %}selected{% endif %}>Last 7 Days</option>
            </select>
            <button id="mode-toggle-btn" class="btn">üìº Replay Mode</button>
            <button id="play-pause-btn" class="btn btn-primary" disabled>‚è∏ Pause</button>
            <button id="reset-btn" class="btn" disabled>üîÑ Reset</button>
            <button id="fullscreen-btn" class="btn">‚õ∂ Fullscreen</button>
            <a href="{{ url_for('index') }}" class="btn">Back to Dashboard</a>
        </div>
    </div>

    <div class="map-stats" style="margin: 20px 0; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">Total Attacks</div>
                <div style="font-size: 1.5em; font-weight: 600; color: var(--accent-color);" id="total-attacks">{{ attacks | length }}</div>
            </div>
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">Unique IPs</div>
                <div style="font-size: 1.5em; font-weight: 600; color: #17a2b8;" id="unique-ips">0</div>
            </div>
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">High-Volume Attackers</div>
                <div style="font-size: 1.5em; font-weight: 600; color: #ffc107;" id="high-volume-count">0</div>
            </div>
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">Honeypot{{ 's' if honeypot_locations|length > 1 else '' }}</div>
                <div style="font-size: 1.2em; font-weight: 600;">
                    {% if honeypot_locations|length > 0 %}
                        {% if honeypot_locations|length == 1 %}
                            {% for hp in honeypot_locations.values() %}
                            {{ hp.name }}
                            {% endfor %}
                        {% else %}
                            {{ honeypot_locations|length }} locations
                        {% endif %}
                    {% else %}
                    Unknown
                    {% endif %}
                </div>
            </div>
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">Current Attack Time</div>
                <div style="font-size: 1.1em; font-weight: 600; color: #ffc107;" id="current-time">--</div>
            </div>
            <div>
                <div style="font-size: 0.9em; color: var(--text-secondary);">Mode</div>
                <div style="font-size: 1.1em; font-weight: 600;" id="mode-indicator">
                    <span style="color: #28a745; animation: pulse 2s ease-in-out infinite;">üî¥ LIVE</span>
                </div>
            </div>
            <div id="progress-container" style="display: none;">
                <div style="font-size: 0.9em; color: var(--text-secondary);">Animation Progress</div>
                <div style="font-size: 1.2em; font-weight: 600;" id="progress-text">0%</div>
            </div>
            <div id="speed-container" style="display: none;">
                <div style="font-size: 0.9em; color: var(--text-secondary);">Speed</div>
                <input type="range" id="speed-slider" min="0.1" max="5" step="0.1" value="1" style="width: 100%;" disabled>
                <div style="text-align: center; font-size: 0.9em;" id="speed-text">1x</div>
            </div>
        </div>
    </div>

    <div style="display: grid; grid-template-columns: 1fr 400px; gap: 20px;">
        <div id="attack-map" style="height: 700px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"></div>

        <!-- Live Attack Feed -->
        <div class="attack-feed-container" style="background: var(--bg-secondary); border-radius: 8px; padding: 15px; height: 700px; display: flex; flex-direction: column;">
            <h3 id="attack-feed-title" style="margin: 0 0 15px 0; font-size: 1.1em;">üì° Live Attack Feed</h3>
            <div style="flex: 1; overflow-y: auto; overflow-x: hidden;" id="attack-feed">
                <div style="color: var(--text-secondary); text-align: center; padding: 20px;">
                    Waiting for live attacks...
                </div>
            </div>
        </div>
    </div>

    <div class="map-legend" style="margin-top: 20px; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
        <div>
            <strong>Legend:</strong>
            <span style="margin-left: 15px;">üî¥ Attacker</span>
            <span style="margin-left: 15px;">üéØ Honeypot</span>
            <span style="margin-left: 15px; color: #dc3545;">‚îÅ‚îÅ‚îÅ</span> <span>Attack Path</span>
            <span style="margin-left: 15px; color: #28a745;">‚îÅ‚îÅ‚îÅ</span> <span>Successful Login</span>
            <span style="margin-left: 15px; color: #ffc107;">‚îÅ‚îÅ‚îÅ</span> <span>üê¶ Canary Token Trigger</span>
        </div>
    </div>
</div>

<style>
/* Honeypot marker - keep it static and visible */
.honeypot-marker-icon {
    transition: none !important;
    animation: none !important;
    transform: none !important;
    position: relative !important;
    pointer-events: auto !important;
}

.attack-path {
    fill: none;
    stroke-dasharray: 5, 5;
    animation: dash 20s linear infinite;
    transition: all 0.3s ease;
}

.canary-path {
    stroke-dasharray: 15, 5;
    animation: dash 10s linear infinite, canary-pulse 2s ease-in-out infinite;
    filter: drop-shadow(0 0 25px #ffc107) drop-shadow(0 0 40px #ffc107);
}

@keyframes canary-pulse {
    0%, 100% {
        opacity: 0.7;
    }
    50% {
        opacity: 1;
    }
}

/* Canary attacker marker */
.canary-attacker-marker {
    animation: canary-marker-pulse 2s ease-in-out infinite;
}

@keyframes canary-marker-pulse {
    0%, 100% {
        transform: scale(1);
        opacity: 0.9;
    }
    50% {
        transform: scale(1.2);
        opacity: 1;
    }
}

@keyframes dash {
    to {
        stroke-dashoffset: -1000;
    }
}

.pew-marker {
    animation: pew-pew 0.5s ease-out;
}

@keyframes pew-pew {
    0% {
        transform: scale(0);
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.pulse-marker {
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
        opacity: 0.8;
    }
    50% {
        transform: scale(1.3);
        opacity: 1;
    }
}

/* Dramatic explosion effect at honeypot */
@keyframes explosion {
    0% {
        transform: scale(0);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.8;
    }
    100% {
        transform: scale(2);
        opacity: 0;
    }
}

/* Honeypot hit flash - no transform to prevent movement */
@keyframes honeypot-flash {
    0%, 100% {
        filter: drop-shadow(0 0 10px rgba(255, 193, 7, 0.8));
    }
    50% {
        filter: drop-shadow(0 0 30px rgba(255, 193, 7, 1))
                drop-shadow(0 0 50px rgba(255, 255, 255, 0.8))
                brightness(1.5);
    }
}

/* Enhanced glow for high-volume attacks */
.high-volume-attack {
    filter: drop-shadow(0 0 20px currentColor)
            drop-shadow(0 0 40px currentColor);
    animation: intense-glow 1s ease-in-out infinite;
}

@keyframes intense-glow {
    0%, 100% {
        opacity: 0.8;
    }
    50% {
        opacity: 1;
    }
}

/* Slide-in animation for attack feed entries */
@keyframes slideIn {
    from {
        transform: translateX(20px);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

/* IP link hover effect */
.ip-link:hover {
    opacity: 0.7;
    text-decoration: underline !important;
    cursor: pointer;
}

/* Fullscreen mode adjustments */
.attack-map-page:fullscreen {
    background: var(--bg-primary);
    padding: 20px;
    overflow-y: auto;
}

.attack-map-page:-webkit-full-screen {
    background: var(--bg-primary);
    padding: 20px;
    overflow-y: auto;
}

.attack-map-page:-moz-full-screen {
    background: var(--bg-primary);
    padding: 20px;
    overflow-y: auto;
}

.attack-map-page:-ms-fullscreen {
    background: var(--bg-primary);
    padding: 20px;
    overflow-y: auto;
}

/* Make map and feed larger in fullscreen */
.attack-map-page:fullscreen #attack-map,
.attack-map-page:-webkit-full-screen #attack-map,
.attack-map-page:-moz-full-screen #attack-map,
.attack-map-page:-ms-fullscreen #attack-map {
    height: calc(100vh - 300px) !important;
}

.attack-map-page:fullscreen .attack-feed-container,
.attack-map-page:-webkit-full-screen .attack-feed-container,
.attack-map-page:-moz-full-screen .attack-feed-container,
.attack-map-page:-ms-fullscreen .attack-feed-container {
    height: calc(100vh - 300px) !important;
}
</style>

<script>
// Update filters and reload page
function updateFilters() {
    const source = document.getElementById('source-filter') ? document.getElementById('source-filter').value : '';
    const hours = document.getElementById('hours-selector').value;

    // Build URL with both parameters
    let url = '?hours=' + hours;
    if (source) {
        url += '&source=' + encodeURIComponent(source);
    }

    window.location.href = url;
}

document.addEventListener('DOMContentLoaded', function() {
    const honeypotLocation = {{ honeypot_location | tojson }};
    const honeypotLocations = {{ honeypot_locations | tojson }};
    const attacks = {{ attacks | tojson }};

    // Check if we have at least one honeypot location
    if (Object.keys(honeypotLocations).length === 0 && !honeypotLocation) {
        document.getElementById('attack-map').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary);">Honeypot location not available. Please configure SERVER_IP in deployment.</div>';
        return;
    }

    // Calculate map center - use first honeypot or fall back to default location
    let mapCenter = [20, 0];  // Default world center
    let mapZoom = 2;

    const honeypotLocationsList = Object.values(honeypotLocations);
    if (honeypotLocationsList.length > 0) {
        // If multiple honeypots, calculate average center
        const avgLat = honeypotLocationsList.reduce((sum, hp) => sum + hp.lat, 0) / honeypotLocationsList.length;
        const avgLon = honeypotLocationsList.reduce((sum, hp) => sum + hp.lon, 0) / honeypotLocationsList.length;
        mapCenter = [avgLat, avgLon];
        mapZoom = honeypotLocationsList.length === 1 ? 3 : 2;
    }

    // Initialize map centered appropriately
    const map = L.map('attack-map', {
        center: mapCenter,
        zoom: mapZoom,
        zoomControl: true,
        preferCanvas: true,  // Use canvas for better performance
        worldCopyJump: false,  // Prevent world wrapping jumps
        maxBounds: null,  // No bounds restriction
        renderer: L.canvas(),  // Canvas renderer for smoother animations
        zoomAnimation: false,  // Disable zoom animation to prevent jumping
        fadeAnimation: false,  // Disable fade animation
        markerZoomAnimation: false  // Disable marker zoom animation
    });

    // Add tile layer (dark theme for pew-pew effect)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '¬© OpenStreetMap, ¬© CartoDB',
        maxZoom: 19,
        subdomains: 'abcd',
        updateWhenIdle: false,
        updateWhenZooming: false,
        keepBuffer: 2
    }).addTo(map);

    // Add honeypot markers - one for each honeypot
    const honeypotMarkers = {};
    const honeypotIcon = L.divIcon({
        className: '',  // No custom class that might interfere
        html: '<div class="honeypot-marker-icon" style="font-size: 32px; text-shadow: 0 0 10px rgba(255, 193, 7, 0.8); display: flex; align-items: center; justify-content: center; width: 100%; height: 100%;">üéØ</div>',
        iconSize: [40, 40],
        iconAnchor: [20, 20]  // This centers the icon on the coordinate
    });

    for (const [sourceName, hp] of Object.entries(honeypotLocations)) {
        const marker = L.marker([hp.lat, hp.lon], {
            icon: honeypotIcon,
            zIndexOffset: 1000
        }).addTo(map);

        marker.bindPopup(`
            <strong>üéØ ${hp.name}</strong><br>
            ${hp.city}, ${hp.country}<br>
            <small style="color: var(--text-secondary);">Source: ${sourceName}</small>
        `);

        honeypotMarkers[sourceName] = marker;
    }

    // Aggregate attacks by IP to determine line thickness
    const ipAttackCounts = {};
    const ipDetails = {};

    attacks.forEach(attack => {
        if (!ipAttackCounts[attack.ip]) {
            ipAttackCounts[attack.ip] = 0;
            ipDetails[attack.ip] = {
                lat: attack.lat,
                lon: attack.lon,
                city: attack.city,
                country: attack.country,
                sessions: [],
                successCount: 0,
                asn: null,
                asn_org: null
            };
        }
        ipAttackCounts[attack.ip]++;
        ipDetails[attack.ip].sessions.push(attack.session_id);
        if (attack.login_success) {
            ipDetails[attack.ip].successCount++;
        }
    });

    // Calculate statistics with new thresholds (10, 20, 40+)
    const uniqueIPCount = Object.keys(ipAttackCounts).length;
    const highVolumeAttackers = Object.values(ipAttackCounts).filter(count => count >= 10).length;

    // Update stats display
    document.getElementById('unique-ips').textContent = uniqueIPCount;
    document.getElementById('high-volume-count').textContent = highVolumeAttackers;

    // Prepare migration data with attack count information
    const migrationData = attacks.map(attack => {
        const attackCount = ipAttackCounts[attack.ip];

        // Scale visual properties based on new thresholds: 1, 10, 20, 40+
        let lineWidth, glowIntensity, isHighVolume;

        if (attackCount >= 40) {
            lineWidth = 12;           // Mega attackers get massive lines
            glowIntensity = 30;       // Intense glow
            isHighVolume = true;
        } else if (attackCount >= 20) {
            lineWidth = 9;            // Heavy attackers
            glowIntensity = 22;
            isHighVolume = true;
        } else if (attackCount >= 10) {
            lineWidth = 6;            // High-volume attackers
            glowIntensity = 15;
            isHighVolume = true;
        } else {
            lineWidth = 3;            // Regular attackers
            glowIntensity = 8;
            isHighVolume = false;
        }

        // Get target honeypot location
        const targetSource = attack._source || 'local';
        const targetHoneypot = honeypotLocations[targetSource];

        return {
            lat: attack.lat,
            lon: attack.lon,
            from: [attack.lat, attack.lon],
            to: targetHoneypot ? [targetHoneypot.lat, targetHoneypot.lon] : [mapCenter[0], mapCenter[1]],
            labels: [`${attack.city}, ${attack.country}`, targetHoneypot ? `${targetHoneypot.city}, ${targetHoneypot.country}` : ''],
            color: attack.login_success ? '#28a745' : '#dc3545',
            value: 1,
            sessionId: attack.session_id,
            ip: attack.ip,
            city: attack.city,
            country: attack.country,
            timestamp: attack.timestamp,  // Attack timestamp for display
            username: attack.username,
            password: attack.password,
            login_success: attack.login_success,
            attackCount: attackCount,  // Total attacks from this IP
            isHighVolume: isHighVolume,  // Flag for high-volume attackers (10+)
            lineWidth: lineWidth,
            glowIntensity: glowIntensity,
            asn: ipDetails[attack.ip]?.asn,  // ASN number
            asn_org: ipDetails[attack.ip]?.asn_org,  // ASN organization
            _source: targetSource,  // Source honeypot
            _targetHoneypot: targetHoneypot  // Target honeypot object
        };
    });

    // Animation state
    let currentIndex = 0;
    let animationRunning = true;
    let animationSpeed = 1;
    let migrationLayer = null;
    let animationInterval = null;
    let clockInterval = null;
    let lastAttackTimestamp = null;  // Timestamp of last displayed attack
    let nextAttackTimestamp = null;  // Timestamp of next attack to display
    let lastAttackWallTime = null;   // Wall-clock time when last attack was displayed
    let attackFeedCount = 0;

    const arcLayers = [];

    // Live mode state
    let liveMode = true;  // Start in live mode by default
    let eventSource = null;
    let liveSessions = {};  // Track live sessions: session_id -> {arc, attack_data, closeTimer}
    let liveAttackCount = 0;
    let liveUniqueIPs = new Set();  // Track unique IPs in live mode
    let liveIPAttackCounts = {};  // Track attack counts per IP in live mode

    // Retry connection state
    let retryCount = 0;
    let maxRetries = 10;
    let retryTimer = null;
    let retryBaseDelay = 2000;  // Start with 2 seconds

    // Update live mode statistics
    function updateLiveStats() {
        if (!liveMode) return;

        // Update total attacks
        document.getElementById('total-attacks').textContent = liveAttackCount;
        document.getElementById('progress-text').textContent = `${liveAttackCount} attacks`;

        // Update unique IPs
        document.getElementById('unique-ips').textContent = liveUniqueIPs.size;

        // Calculate high-volume attackers (10+ attacks)
        const highVolumeCount = Object.values(liveIPAttackCounts).filter(count => count >= 10).length;
        document.getElementById('high-volume-count').textContent = highVolumeCount;
    }

    // Track IP for live stats
    function trackLiveIP(ip) {
        liveUniqueIPs.add(ip);
        liveIPAttackCounts[ip] = (liveIPAttackCounts[ip] || 0) + 1;
        updateLiveStats();
    }

    // Calculate points along a curved arc using quadratic bezier curve
    function calculateArcPoints(start, end, numPoints = 50) {
        const points = [];

        // Calculate control point for bezier curve
        // Midpoint between start and end
        const midLat = (start[0] + end[0]) / 2;
        const midLon = (start[1] + end[1]) / 2;

        // Offset perpendicular to the line for curve effect
        const dx = end[1] - start[1];
        const dy = end[0] - start[0];
        const distance = Math.sqrt(dx * dx + dy * dy);
        const offset = distance * 0.3; // 30% offset for nice curve

        // Control point perpendicular to midpoint
        const controlLat = midLat + (-dx / distance) * offset;
        const controlLon = midLon + (dy / distance) * offset;

        // Generate points along quadratic bezier curve
        for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            const invT = 1 - t;

            // Quadratic bezier formula: B(t) = (1-t)^2 * P0 + 2(1-t)t * P1 + t^2 * P2
            const lat = invT * invT * start[0] +
                       2 * invT * t * controlLat +
                       t * t * end[0];
            const lon = invT * invT * start[1] +
                       2 * invT * t * controlLon +
                       t * t * end[1];

            points.push([lat, lon]);
        }

        return points;
    }

    function addImpactExplosion(attack) {
        // Get target honeypot location
        const targetHoneypot = attack._targetHoneypot || honeypotLocations[attack._source];
        if (!targetHoneypot) return;

        // Create dramatic impact explosion at honeypot location (scaled to new thresholds)
        let explosionSize;
        if (attack.attackCount >= 40) {
            explosionSize = 100;  // MEGA explosion
        } else if (attack.attackCount >= 20) {
            explosionSize = 75;   // Heavy explosion
        } else if (attack.attackCount >= 10) {
            explosionSize = 50;   // High-volume explosion
        } else {
            explosionSize = 35;   // Regular explosion
        }

        const explosionIcon = L.divIcon({
            className: 'impact-explosion',
            html: `<div style="
                width: ${explosionSize}px;
                height: ${explosionSize}px;
                border-radius: 50%;
                background: radial-gradient(circle, ${attack.color} 0%, transparent 70%);
                box-shadow: 0 0 ${explosionSize}px ${attack.color},
                           0 0 ${explosionSize * 0.5}px ${attack.color},
                           inset 0 0 ${explosionSize * 0.3}px ${attack.color};
                animation: explosion 0.6s ease-out;
                opacity: 0;
            "></div>`,
            iconSize: [explosionSize, explosionSize],
            iconAnchor: [explosionSize / 2, explosionSize / 2]
        });

        const explosionMarker = L.marker([targetHoneypot.lat, targetHoneypot.lon], {
            icon: explosionIcon,
            zIndexOffset: 999
        }).addTo(map);

        // Flash the honeypot marker on impact
        const targetMarker = honeypotMarkers[attack._source];
        if (targetMarker && targetMarker._icon) {
            const iconDiv = targetMarker._icon.querySelector('.honeypot-marker-icon');
            if (iconDiv) {
                iconDiv.style.animation = 'honeypot-flash 0.6s ease-out';
                setTimeout(() => {
                    iconDiv.style.animation = '';
                }, 600);
            }
        }

        // Remove explosion after animation
        setTimeout(() => {
            map.removeLayer(explosionMarker);
        }, 600);
    }

    function addAttackArc(attack) {
        // Get target honeypot location
        const targetHoneypot = attack._targetHoneypot || honeypotLocations[attack._source];
        if (!targetHoneypot) return null;

        // Calculate curved path points
        const arcPoints = calculateArcPoints(
            [attack.lat, attack.lon],
            [targetHoneypot.lat, targetHoneypot.lon]
        );

        // Determine visual properties based on attack volume
        const lineWidth = attack.lineWidth || 2;
        const glowIntensity = attack.glowIntensity || 5;
        const isHighVolume = attack.isHighVolume || false;

        // Create curved arc polyline with dynamic styling
        const arc = L.polyline(arcPoints, {
            color: attack.login_success ? '#28a745' : '#dc3545',
            weight: lineWidth,  // Thicker lines for more attacks
            opacity: 0.8,
            dashArray: isHighVolume ? '10, 5' : '5, 10',  // Different dash pattern for high volume
            className: 'attack-path'
        });

        // Add glow effect using SVG filter
        if (arc._path) {
            arc._path.style.filter = `drop-shadow(0 0 ${glowIntensity}px ${attack.color})`;
        }

        arc.addTo(map);
        arcLayers.push(arc);

        // Add popup to arc with attack count
        const targetHoneypotName = targetHoneypot.name || attack._source || 'local';
        arc.bindPopup(`
            <strong>${attack.city}, ${attack.country}</strong> ‚Üí <strong style="color:#28a745;">üçØ ${targetHoneypotName}</strong><br>
            IP: <a href="/sessions?ip=${attack.ip}" target="_blank">${attack.ip}</a><br>
            ${attack.attackCount > 1 ? `<span style="color: #ffc107; font-weight: bold;">‚ö° ${attack.attackCount} attacks from this IP</span><br>` : ''}
            <a href="/session/${attack.sessionId}" target="_blank">View Session ‚Üí</a>
        `);

        // Add impact explosion at honeypot location
        addImpactExplosion(attack);

        // Minimum display time: 2 minutes for all attacks
        // Successful logins stay even longer to ensure they're noticed
        const displayDuration = attack.login_success ? 180000 : 120000;  // 3 min for success, 2 min for failed

        // Auto-fade and remove after displayDuration
        setTimeout(() => {
            // Fade out animation
            let opacity = 0.8;
            const fadeInterval = setInterval(() => {
                opacity -= 0.1;
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    // Remove from map
                    map.removeLayer(arc);
                    // Remove from tracking arrays
                    const arcIndex = arcLayers.indexOf(arc);
                    if (arcIndex > -1) arcLayers.splice(arcIndex, 1);
                } else {
                    arc.setStyle({ opacity: opacity });
                }
            }, 200);
        }, displayDuration);

        return arc;
    }

    function startReplayClock() {
        // Stop any existing clock
        if (clockInterval) clearInterval(clockInterval);

        // Update clock every 100ms by interpolating between last and next attack timestamps
        clockInterval = setInterval(() => {
            if (animationRunning && lastAttackTimestamp && nextAttackTimestamp && lastAttackWallTime) {
                // Calculate progress between last and next attack
                const attackInterval = 500 / animationSpeed; // Time between attacks in ms
                const elapsedSinceLastAttack = Date.now() - lastAttackWallTime;
                const progress = Math.min(elapsedSinceLastAttack / attackInterval, 1.0);

                // Interpolate between last and next attack timestamps
                const lastTime = new Date(lastAttackTimestamp).getTime();
                const nextTime = new Date(nextAttackTimestamp).getTime();
                const timeDiff = nextTime - lastTime;
                const currentTime = new Date(lastTime + (timeDiff * progress));

                const formattedTime = currentTime.toLocaleString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                document.getElementById('current-time').textContent = formattedTime;
            } else if (lastAttackTimestamp && !nextAttackTimestamp) {
                // No next attack, just show the last attack time
                const currentTime = new Date(lastAttackTimestamp);
                const formattedTime = currentTime.toLocaleString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });
                document.getElementById('current-time').textContent = formattedTime;
            }
        }, 100);
    }

    function addToAttackFeed(attack) {
        const feed = document.getElementById('attack-feed');

        // Clear "waiting" message on first attack
        if (attackFeedCount === 0) {
            feed.innerHTML = '';
        }

        attackFeedCount++;

        const date = new Date(attack.timestamp);

        // Format: YYYY-MM-DD HH:MM:SS TIMEZONE
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        // Get timezone abbreviation (e.g., "EST", "PST", "UTC")
        const timezoneName = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();

        const timeStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${timezoneName}`;

        const statusBadge = attack.login_success
            ? '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: 600;">SUCCESS</span>'
            : '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: 600;">FAILED</span>';

        // Get ASN info if available
        const asnInfo = attack.asn ? `AS${attack.asn}` : '';
        const asnOrg = attack.asn_org || '';

        // Format credentials
        const credentials = attack.username && attack.password
            ? `${attack.username}:${attack.password}`
            : (attack.username ? attack.username : 'No username/password provided');

        const entry = document.createElement('div');
        entry.style.cssText = `
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-primary);
            border-left: 4px solid ${attack.login_success ? '#28a745' : '#dc3545'};
            border-radius: 4px;
            font-size: 0.85em;
            animation: slideIn 0.3s ease-out;
        `;

        // Build location line with ASN
        let locationLine = `${attack.city}, ${attack.country}`;
        if (asnInfo) {
            locationLine += ` - ${asnInfo}`;
            if (asnOrg) {
                locationLine += ` ${asnOrg.substring(0, 20)}`;
            }
        }

        // Get target honeypot name
        const targetHoneypot = attack._targetHoneypot || honeypotLocations[attack._source];
        const targetName = targetHoneypot ? targetHoneypot.name : (attack._source || 'local');

        entry.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <strong style="color: var(--accent-color);">
                    <a href="/session/${attack.sessionId}" target="_blank" class="ip-link" style="color: var(--accent-color); text-decoration: none; transition: opacity 0.2s;">${attack.ip}</a>
                    <span style="color: var(--text-secondary); font-weight: normal;"> ‚Üí </span>
                    <span style="color: #28a745;">üçØ ${targetName}</span>
                </strong>
                ${statusBadge}
            </div>
            <div style="color: var(--text-secondary); font-size: 0.9em;">
                <div>${locationLine}</div>
                <div style="margin-top: 3px;">${credentials}</div>
                <div style="margin-top: 3px; color: var(--text-tertiary);">${timeStr}</div>
            </div>
        `;

        // Add to top of feed
        feed.insertBefore(entry, feed.firstChild);

        // Keep only last 20 entries
        while (feed.children.length > 20) {
            feed.removeChild(feed.lastChild);
        }
    }

    function animateAttacks() {
        if (!animationRunning) return;

        if (currentIndex < migrationData.length) {
            const currentAttack = migrationData[currentIndex];
            addAttackArc(currentAttack);

            // Update clock timestamps
            lastAttackTimestamp = currentAttack.timestamp;
            lastAttackWallTime = Date.now();

            // Set next attack timestamp if there is one
            if (currentIndex + 1 < migrationData.length) {
                nextAttackTimestamp = migrationData[currentIndex + 1].timestamp;
            } else {
                nextAttackTimestamp = null;
            }

            // Start clock on first attack
            if (currentIndex === 0) {
                startReplayClock();
            }

            // Add to attack feed
            addToAttackFeed(currentAttack);

            currentIndex++;

            const progress = Math.round((currentIndex / migrationData.length) * 100);
            document.getElementById('progress-text').textContent = `${progress}%`;

            animationInterval = setTimeout(animateAttacks, 500 / animationSpeed);
        } else {
            // Animation complete, pause for a moment then reset
            if (clockInterval) clearInterval(clockInterval);

            setTimeout(() => {
                if (animationRunning) {
                    clearMap();
                    currentIndex = 0;
                    attackFeedCount = 0;
                    lastAttackTimestamp = null;
                    nextAttackTimestamp = null;
                    lastAttackWallTime = null;
                    document.getElementById('current-time').textContent = '--';
                    document.getElementById('attack-feed').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Waiting for attacks...</div>';
                    animateAttacks();
                }
            }, 3000);
        }
    }

    function clearMap() {
        // Remove all arcs
        arcLayers.forEach(arc => map.removeLayer(arc));
        arcLayers.length = 0;
        document.getElementById('progress-text').textContent = '0%';
    }

    // ===== LIVE MODE FUNCTIONS =====

    function connectEventSource() {
        // Close existing connection if any
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }

        // Clear any pending retry timer
        if (retryTimer) {
            clearTimeout(retryTimer);
            retryTimer = null;
        }

        try {
            // Create new EventSource connection
            eventSource = new EventSource('/api/attack-stream');

            eventSource.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.event === 'connected') {
                    // Connection established successfully
                    console.log('SSE stream connected:', data.message);
                } else if (data.event === 'error') {
                    // Server-side error
                    console.error('SSE stream error:', data.message);
                    document.getElementById('mode-indicator').innerHTML =
                        '<span style="color: #dc3545;">‚ö†Ô∏è Stream Error: ' + data.message + '</span>';
                } else if (data.event === 'connect') {
                    handleLiveConnect(data);
                } else if (data.event === 'login_success') {
                    handleLiveLoginSuccess(data);
                } else if (data.event === 'login_failed') {
                    handleLiveLoginFailed(data);
                } else if (data.event === 'command_input') {
                    handleLiveCommand(data);
                } else if (data.event === 'session_closed') {
                    handleLiveSessionClosed(data);
                } else if (data.event === 'canary_trigger') {
                    handleCanaryTrigger(data);
                }
            };

            eventSource.onerror = function(err) {
                console.error('EventSource error:', err, 'ReadyState:', eventSource?.readyState);

                // Check if connection is permanently closed
                if (eventSource && eventSource.readyState === EventSource.CLOSED) {
                    console.log('Connection closed, attempting manual retry...');

                    // Calculate exponential backoff delay
                    const delay = Math.min(retryBaseDelay * Math.pow(2, retryCount), 60000); // Max 60 seconds

                    if (retryCount < maxRetries) {
                        retryCount++;
                        const secondsUntilRetry = Math.round(delay / 1000);

                        document.getElementById('mode-indicator').innerHTML =
                            `<span style="color: #ffc107;">üîÑ Reconnecting... (${retryCount}/${maxRetries}, next in ${secondsUntilRetry}s)</span>`;

                        console.log(`Retry attempt ${retryCount}/${maxRetries} in ${secondsUntilRetry} seconds`);

                        // Schedule reconnection with countdown update
                        let countdown = secondsUntilRetry;
                        const countdownInterval = setInterval(() => {
                            countdown--;
                            if (countdown > 0) {
                                document.getElementById('mode-indicator').innerHTML =
                                    `<span style="color: #ffc107;">üîÑ Reconnecting... (${retryCount}/${maxRetries}, next in ${countdown}s)</span>`;
                            }
                        }, 1000);

                        retryTimer = setTimeout(() => {
                            clearInterval(countdownInterval);
                            if (liveMode) {  // Only retry if still in live mode
                                connectEventSource();
                            }
                        }, delay);
                    } else {
                        // Max retries exceeded
                        document.getElementById('mode-indicator').innerHTML =
                            '<span style="color: #dc3545;">‚ö†Ô∏è Connection Failed - Max retries exceeded. <button onclick="location.reload()" style="margin-left: 10px; padding: 2px 8px; cursor: pointer;">Reload Page</button></span>';
                        console.error('Max retries exceeded. Connection abandoned.');
                    }
                } else if (eventSource && eventSource.readyState === EventSource.CONNECTING) {
                    // Browser is still trying to connect
                    document.getElementById('mode-indicator').innerHTML =
                        '<span style="color: #ffc107;">üîÑ Connecting...</span>';
                }
            };

            eventSource.onopen = function() {
                // Connection successful - reset retry counter
                console.log('EventSource connection established');
                retryCount = 0;
                document.getElementById('mode-indicator').innerHTML =
                    '<span style="color: #28a745; animation: pulse 2s ease-in-out infinite;">üî¥ LIVE</span>';
            };
        } catch (error) {
            console.error('Failed to create EventSource:', error);
            document.getElementById('mode-indicator').innerHTML =
                '<span style="color: #dc3545;">‚ö†Ô∏è Connection Error</span>';
        }
    }

    function startLiveMode() {
        liveMode = true;
        animationRunning = false;

        // Stop replay mode
        if (animationInterval) clearTimeout(animationInterval);
        if (clockInterval) clearInterval(clockInterval);
        clearMap();

        // Reset retry counter when entering live mode
        retryCount = 0;

        // Reset live stats
        liveAttackCount = 0;
        liveUniqueIPs.clear();
        liveIPAttackCounts = {};
        updateLiveStats();

        // Update UI
        document.getElementById('mode-toggle-btn').textContent = 'üìº Replay Mode';
        document.getElementById('mode-toggle-btn').className = 'btn';
        document.getElementById('mode-indicator').innerHTML = '<span style="color: #ffc107;">üîÑ Connecting...</span>';
        document.getElementById('attack-feed-title').textContent = 'üì° Live Attack Feed';
        document.getElementById('play-pause-btn').disabled = true;
        document.getElementById('reset-btn').disabled = true;
        document.getElementById('speed-slider').disabled = true;
        document.getElementById('hours-selector').disabled = true;
        document.getElementById('progress-text').textContent = 'LIVE';
        document.getElementById('attack-feed').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Waiting for live attacks...</div>';

        // Hide Speed and Animation Progress in live mode
        document.getElementById('speed-container').style.display = 'none';
        document.getElementById('progress-container').style.display = 'none';

        // Start live clock showing current time
        function updateLiveClock() {
            const now = new Date();
            const formattedTime = now.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            document.getElementById('current-time').textContent = formattedTime;
        }
        updateLiveClock(); // Update immediately
        clockInterval = setInterval(updateLiveClock, 1000); // Update every second

        // Start SSE connection with retry logic
        connectEventSource();
    }

    function handleCanaryTrigger(data) {
        console.log('[Canary] Received canary_trigger event:', data);
        liveAttackCount++;
        trackLiveIP(data.ip);

        // Create canary token event with distinctive color (golden/amber)
        const canaryEvent = {
            lat: data.lat,
            lon: data.lon,
            ip: data.ip,
            city: data.city,
            country: data.country,
            timestamp: data.timestamp,
            token_type: data.token_type,
            token_name: data.token_name,
            trigger_user_agent: data.trigger_user_agent,
            trigger_location: data.trigger_location,
            asn: data.asn,
            asn_org: data.asn_org,
            attackCount: 1,
            isHighVolume: true,  // Canary tokens are always high priority
            lineWidth: 8,  // Thicker line for canary tokens
            glowIntensity: 25,  // High glow
            color: '#ffc107'  // Golden/amber color for canary tokens
        };

        // Get first available honeypot location (canary tokens don't have source attribution in live mode)
        const firstHoneypot = Object.values(honeypotLocations)[0];
        if (!firstHoneypot) return;

        // Calculate curved path
        const arcPoints = calculateArcPoints(
            [data.lat, data.lon],
            [firstHoneypot.lat, firstHoneypot.lon]
        );

        // Create distinctive arc for canary token
        const arc = L.polyline(arcPoints, {
            color: '#ffc107',  // Golden/amber color
            weight: 8,
            opacity: 0.9,
            dashArray: '15, 5',  // Distinctive dash pattern
            className: 'attack-path canary-path'
        });

        // Enhanced glow for canary tokens
        if (arc._path) {
            arc._path.style.filter = 'drop-shadow(0 0 25px #ffc107) drop-shadow(0 0 40px #ffc107)';
        }

        arc.addTo(map);
        arcLayers.push(arc);

        // Bind popup with canary token info
        arc.bindPopup(`
            <strong>üê¶ CANARY TOKEN TRIGGERED!</strong><br>
            <span style="color: #ffc107; font-weight: bold;">${data.token_name}</span><br>
            Type: ${data.token_type}<br>
            <strong>${data.city}, ${data.country}</strong><br>
            IP: <a href="/canary-alerts" target="_blank">${data.ip}</a><br>
            ${data.asn ? `ASN: AS${data.asn} ${data.asn_org || ''}` : ''}
        `);

        // Add yellow marker at attacker's location
        const attackerIcon = L.divIcon({
            className: 'canary-attacker-marker',
            html: '<div style="font-size: 24px; filter: drop-shadow(0 0 10px #ffc107);">üê¶</div>',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });

        const attackerMarker = L.marker([data.lat, data.lon], {
            icon: attackerIcon,
            zIndexOffset: 500
        }).addTo(map);

        attackerMarker.bindPopup(`
            <strong>üê¶ Canary Token Source</strong><br>
            ${data.city}, ${data.country}<br>
            IP: <a href="/canary-alerts" target="_blank">${data.ip}</a>
        `);

        arcLayers.push(attackerMarker);

        // Add dramatic explosion for canary token
        addImpactExplosion(canaryEvent);

        // Canary tokens stay visible longer (5 minutes)
        const displayDuration = 300000;  // 5 minutes

        // Store in liveSessions with canary flag
        const sessionId = `canary-${data.id}`;
        liveSessions[sessionId] = {
            arc: arc,
            marker: attackerMarker,  // Store the attacker marker
            attack_data: canaryEvent,
            createdAt: Date.now(),
            closeTimer: null,
            minDisplayTimer: null,
            minDisplayDuration: displayDuration,
            canRemoveArc: false,
            isCanary: true,  // Flag to identify canary tokens
            feedElement: null
        };

        // Set minimum display timer
        liveSessions[sessionId].minDisplayTimer = setTimeout(() => {
            if (liveSessions[sessionId]) {
                liveSessions[sessionId].canRemoveArc = true;
                removeSessionArc(sessionId);
                // Also remove the marker
                if (liveSessions[sessionId].marker) {
                    map.removeLayer(liveSessions[sessionId].marker);
                    liveSessions[sessionId].marker = null;
                }
            }
        }, displayDuration);

        // Create feed entry for canary token
        const feed = document.getElementById('attack-feed');

        // Clear "waiting" message on first event
        if (Object.keys(liveSessions).length === 1) {
            feed.innerHTML = '';
        }

        const date = new Date(data.timestamp);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const timezoneName = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();
        const timeStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${timezoneName}`;

        const asnInfo = data.asn ? `AS${data.asn}` : '';
        const asnOrg = data.asn_org || '';

        let locationLine = `${data.city}, ${data.country}`;
        if (asnInfo) {
            locationLine += ` - ${asnInfo}`;
            if (asnOrg) {
                locationLine += ` ${asnOrg.substring(0, 20)}`;
            }
        }

        const entry = document.createElement('div');
        entry.style.cssText = `
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-primary);
            border-left: 4px solid #ffc107;
            border-radius: 4px;
            font-size: 0.85em;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.3);
        `;

        entry.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <strong style="color: #ffc107;">üê¶ <a href="/canary-alerts" target="_blank" class="ip-link" style="color: #ffc107; text-decoration: none; transition: opacity 0.2s;">${data.ip}</a></strong>
                <span style="background: #ffc107; color: #000; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: 600;">CANARY TOKEN</span>
            </div>
            <div style="color: var(--text-secondary); font-size: 0.9em;">
                <div style="color: #ffc107; font-weight: bold;">${data.token_name} (${data.token_type})</div>
                <div>${locationLine}</div>
                <div style="margin-top: 3px; color: var(--text-tertiary);">${timeStr}</div>
            </div>
        `;

        // Insert at top of feed
        feed.insertBefore(entry, feed.firstChild);
        liveSessions[sessionId].feedElement = entry;

        // Update stats
        document.getElementById('progress-text').textContent = `${liveAttackCount} attacks`;
    }

    function stopLiveMode() {
        liveMode = false;

        // Close SSE connection
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }

        // Clear retry timer
        if (retryTimer) {
            clearTimeout(retryTimer);
            retryTimer = null;
        }

        // Reset retry counter
        retryCount = 0;

        // Stop live clock
        if (clockInterval) {
            clearInterval(clockInterval);
            clockInterval = null;
        }

        // Clear all live sessions and timers
        for (const sessionId in liveSessions) {
            const session = liveSessions[sessionId];
            if (session.arc) map.removeLayer(session.arc);
            if (session.marker) map.removeLayer(session.marker);  // Remove canary marker
            if (session.closeTimer) clearTimeout(session.closeTimer);
            if (session.minDisplayTimer) clearTimeout(session.minDisplayTimer);
            if (session.autoCollapseTimer) clearTimeout(session.autoCollapseTimer);
        }
        liveSessions = {};
        liveAttackCount = 0;

        // Update UI
        document.getElementById('mode-toggle-btn').textContent = 'üì° Go Live';
        document.getElementById('mode-toggle-btn').className = 'btn btn-success';
        document.getElementById('mode-indicator').innerHTML = '<span style="color: var(--text-secondary);">üìº Replay</span>';
        document.getElementById('attack-feed-title').textContent = 'üìº Replay Attack Feed';
        document.getElementById('play-pause-btn').disabled = false;
        document.getElementById('reset-btn').disabled = false;
        document.getElementById('speed-slider').disabled = false;
        document.getElementById('hours-selector').disabled = false;
        document.getElementById('current-time').textContent = '--';
        document.getElementById('progress-text').textContent = '0%';
        document.getElementById('attack-feed').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Waiting for attacks...</div>';

        // Restore replay mode stats
        document.getElementById('total-attacks').textContent = attacks.length;
        document.getElementById('unique-ips').textContent = uniqueIPCount;
        document.getElementById('high-volume-count').textContent = highVolumeAttackers;

        // Show Speed and Animation Progress in replay mode
        document.getElementById('speed-container').style.display = 'block';
        document.getElementById('progress-container').style.display = 'block';

        // Restart replay mode
        animationRunning = true;
        currentIndex = 0;
        attackFeedCount = 0;
        animateAttacks();
    }

    function handleLiveConnect(data) {
        liveAttackCount++;
        trackLiveIP(data.ip);

        const attack = {
            lat: data.lat,
            lon: data.lon,
            ip: data.ip,
            city: data.city,
            country: data.country,
            timestamp: data.timestamp,
            username: null,
            password: null,
            login_success: false,
            sessionId: data.session_id,
            asn: data.asn,
            asn_org: data.asn_org,
            attackCount: 1,
            isHighVolume: false,
            lineWidth: 3,
            glowIntensity: 8,
            color: '#dc3545'
        };

        // Get first available honeypot location (live connections don't have source attribution yet)
        const firstHoneypot = Object.values(honeypotLocations)[0];
        if (!firstHoneypot) return;

        // Calculate curved path
        const arcPoints = calculateArcPoints(
            [data.lat, data.lon],
            [firstHoneypot.lat, firstHoneypot.lon]
        );

        // Create arc
        const arc = L.polyline(arcPoints, {
            color: '#dc3545',
            weight: 3,
            opacity: 0.8,
            dashArray: '5, 10',
            className: 'attack-path'
        });

        arc.addTo(map);
        arcLayers.push(arc);

        // Bind popup
        arc.bindPopup(`
            <strong>${data.city}, ${data.country}</strong><br>
            IP: <a href="/sessions?ip=${data.ip}" target="_blank">${data.ip}</a><br>
            Session: ${data.session_id}
        `);

        // Add explosion
        addImpactExplosion(attack);

        // Store session with creation timestamp and command tracking
        liveSessions[data.session_id] = {
            arc: arc,
            attack_data: attack,
            createdAt: Date.now(),
            closeTimer: null,
            minDisplayTimer: null,
            minDisplayDuration: 120000,  // Minimum 2 minutes display
            canRemoveArc: false,  // Flag to indicate if arc can be removed
            isExpanded: false,
            commandBuffer: [],
            lastActivityTime: Date.now(),
            isTyping: false,
            autoCollapseTimer: null,
            commandCount: 0,
            feedElement: null  // Will store the DOM element
        };

        // Set minimum display timer - arc cannot be removed before this expires
        liveSessions[data.session_id].minDisplayTimer = setTimeout(() => {
            if (liveSessions[data.session_id]) {
                liveSessions[data.session_id].canRemoveArc = true;
                // If session already closed and waiting to be removed, remove it now
                if (liveSessions[data.session_id].isClosed && !liveSessions[data.session_id].arc) {
                    // Arc was already removed, we can clean up
                } else if (liveSessions[data.session_id].pendingRemoval) {
                    // Session closed before min time, now we can remove arc
                    removeSessionArc(data.session_id);
                }
            }
        }, 120000);  // 2 minutes

        // Create feed element
        const feed = document.getElementById('attack-feed');

        // Clear "waiting" message on first attack
        if (Object.keys(liveSessions).length === 1) {
            feed.innerHTML = '';
        }

        const entry = document.createElement('div');
        entry.style.cssText = `
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-primary);
            border-left: 4px solid ${attack.login_success ? '#28a745' : '#dc3545'};
            border-radius: 4px;
            font-size: 0.85em;
            animation: slideIn 0.3s ease-out;
        `;

        feed.insertBefore(entry, feed.firstChild);
        liveSessions[data.session_id].feedElement = entry;

        // Initial render
        updateLiveFeedEntry(liveSessions[data.session_id]);

        // Update stats
        document.getElementById('progress-text').textContent = `${liveAttackCount} attacks`;
    }

    function handleLiveLoginSuccess(data) {
        if (liveSessions[data.session_id]) {
            const session = liveSessions[data.session_id];
            session.attack_data.login_success = true;
            session.attack_data.username = data.username;
            session.attack_data.password = data.password;
            session.attack_data.timestamp = data.timestamp;

            // Update arc to green
            if (session.arc) {
                session.arc.setStyle({
                    color: '#28a745',
                    weight: 6,
                    opacity: 0.9
                });
            }

            // Update border color to green
            if (session.feedElement) {
                session.feedElement.style.borderLeft = '4px solid #28a745';
            }

            // Clear the auto-remove timer for failed attacks
            if (session.closeTimer) {
                clearTimeout(session.closeTimer);
                session.closeTimer = null;
            }

            // Extend minimum display duration for successful logins to 3 minutes
            session.minDisplayDuration = 180000;  // 3 minutes for successful logins

            // Reset the minimum display timer with extended duration
            if (session.minDisplayTimer) {
                clearTimeout(session.minDisplayTimer);
            }
            session.canRemoveArc = false;
            session.minDisplayTimer = setTimeout(() => {
                if (liveSessions[data.session_id]) {
                    liveSessions[data.session_id].canRemoveArc = true;
                    if (liveSessions[data.session_id].pendingRemoval) {
                        removeSessionArc(data.session_id);
                    }
                }
            }, session.minDisplayDuration);

            // Update feed entry
            updateLiveFeedEntry(session);

            // Re-sort feed to keep successful logins at top
            sortLiveFeed();
        }
    }

    function handleLiveLoginFailed(data) {
        if (liveSessions[data.session_id]) {
            const session = liveSessions[data.session_id];
            // Only update if we don't already have credentials
            if (!session.attack_data.username) {
                session.attack_data.username = data.username;
                session.attack_data.password = data.password;
                session.attack_data.timestamp = data.timestamp;

                // Update feed entry with credentials
                updateLiveFeedEntry(session);
            }
        }
    }

    function sortLiveFeed() {
        const feed = document.getElementById('attack-feed');
        const sessions = Object.values(liveSessions).filter(s => s.feedElement);

        // Sort sessions by priority:
        // 1. Active sessions with commands (typing indicator) at top
        // 2. Successful logins without commands
        // 3. Failed logins at bottom
        // Within each tier, sort by last activity time (most recent first)
        sessions.sort((a, b) => {
            const now = Date.now();
            const aActive = a.commandCount > 0 && (now - a.lastActivityTime < 30000);  // Active in last 30s
            const bActive = b.commandCount > 0 && (now - b.lastActivityTime < 30000);

            // Active sessions first
            if (aActive && !bActive) return -1;
            if (!aActive && bActive) return 1;

            // Then successful logins
            if (a.attack_data.login_success && !b.attack_data.login_success) return -1;
            if (!a.attack_data.login_success && b.attack_data.login_success) return 1;

            // Within same tier, sort by last activity
            return b.lastActivityTime - a.lastActivityTime;
        });

        // Re-append in sorted order
        sessions.forEach(session => {
            feed.appendChild(session.feedElement);
        });
    }

    function resetAutoCollapseTimer(sessionId) {
        const session = liveSessions[sessionId];
        if (!session) return;

        // Clear existing timer
        if (session.autoCollapseTimer) {
            clearTimeout(session.autoCollapseTimer);
        }

        // Set new timer (10 seconds)
        if (session.isExpanded) {
            session.autoCollapseTimer = setTimeout(() => {
                session.isExpanded = false;
                updateLiveFeedEntry(session);
            }, 10000);
        }
    }

    function updateLiveFeedEntry(session) {
        if (!session.feedElement) return;

        const attack = session.attack_data;
        const date = new Date(attack.timestamp);

        // Format timestamp
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const timezoneName = date.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();
        const timeStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds} ${timezoneName}`;

        const statusBadge = attack.login_success
            ? '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: 600;">SUCCESS</span>'
            : '<span style="background: #dc3545; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.8em; font-weight: 600;">FAILED</span>';

        const asnInfo = attack.asn ? `AS${attack.asn}` : '';
        const asnOrg = attack.asn_org || '';
        const credentials = attack.username && attack.password
            ? `${attack.username}:${attack.password}`
            : (attack.username ? attack.username : 'No username/password provided');

        let locationLine = `${attack.city}, ${attack.country}`;
        if (asnInfo) {
            locationLine += ` - ${asnInfo}`;
            if (asnOrg) {
                locationLine += ` ${asnOrg.substring(0, 20)}`;
            }
        }

        // Typing indicator
        const typingIndicator = session.commandCount > 0 ? ' ‚å®Ô∏è' : '';
        const expandIcon = session.isExpanded ? '‚ñº' : '‚ñ∂';

        // Get target honeypot name (for live mode, use first available honeypot)
        const firstHoneypot = Object.values(honeypotLocations)[0];
        const targetName = firstHoneypot ? firstHoneypot.name : 'local';

        // Build command display
        let commandDisplay = '';
        if (session.commandCount > 0 && !session.isExpanded) {
            commandDisplay = `<div style="margin-top: 5px; color: var(--text-secondary); font-size: 0.85em;">üí¨ ${session.commandCount} command${session.commandCount > 1 ? 's' : ''} executed ‚Ä¢ Click to view</div>`;
        } else if (session.isExpanded && session.commandBuffer.length > 0) {
            const commandLines = session.commandBuffer.map(cmd =>
                `<div style="color: #4CAF50;">$ ${cmd.command}</div>`
            ).join('');
            commandDisplay = `
                <div style="margin-top: 8px; padding: 10px; background: #1e1e1e; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85em; max-height: 200px; overflow-y: auto;">
                    <div style="color: #888; margin-bottom: 5px; font-size: 0.9em;">‚îÄ LIVE SESSION ‚îÄ</div>
                    ${commandLines}
                </div>
            `;
        }

        session.feedElement.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <strong style="color: var(--accent-color);">
                    ${expandIcon} <a href="/session/${attack.sessionId}" target="_blank" class="ip-link" style="color: var(--accent-color); text-decoration: none; transition: opacity 0.2s;">${attack.ip}</a>${typingIndicator}
                    <span style="color: var(--text-secondary); font-weight: normal;"> ‚Üí </span>
                    <span style="color: #28a745;">üçØ ${targetName}</span>
                </strong>
                ${statusBadge}
            </div>
            <div style="color: var(--text-secondary); font-size: 0.9em;">
                <div>${locationLine}</div>
                <div style="margin-top: 3px;">${credentials}</div>
                <div style="margin-top: 3px; color: var(--text-tertiary);">${timeStr}</div>
                ${commandDisplay}
            </div>
        `;

        // Re-attach click handler for expand/collapse
        session.feedElement.style.cursor = 'pointer';
        session.feedElement.onclick = (e) => {
            // Don't toggle if clicking the session link
            if (e.target.tagName === 'A') return;

            session.isExpanded = !session.isExpanded;
            if (session.isExpanded) {
                resetAutoCollapseTimer(attack.sessionId);
            } else {
                if (session.autoCollapseTimer) {
                    clearTimeout(session.autoCollapseTimer);
                }
            }
            updateLiveFeedEntry(session);
        };
    }

    function handleLiveCommand(data) {
        if (liveSessions[data.session_id]) {
            const session = liveSessions[data.session_id];

            // Add command to buffer
            session.commandBuffer.push({
                command: data.command,
                timestamp: data.timestamp
            });

            // Keep only last 15 commands
            if (session.commandBuffer.length > 15) {
                session.commandBuffer.shift();
            }

            session.commandCount++;
            session.lastActivityTime = Date.now();
            session.isTyping = false;

            // Reset auto-collapse timer if expanded
            if (session.isExpanded) {
                resetAutoCollapseTimer(data.session_id);
            }

            // Update feed entry
            updateLiveFeedEntry(session);

            // Re-sort feed to keep active sessions at top
            sortLiveFeed();
        }
    }

    // Helper function to remove session arc with fade animation
    function removeSessionArc(sessionId) {
        const session = liveSessions[sessionId];
        if (!session || !session.arc) return;

        // Fade out arc
        let opacity = 0.9;
        const fadeInterval = setInterval(() => {
            opacity -= 0.1;
            if (opacity <= 0) {
                clearInterval(fadeInterval);
                if (session.arc) {
                    map.removeLayer(session.arc);
                    session.arc = null;
                }
            } else {
                if (session.arc) {
                    session.arc.setStyle({ opacity: opacity });
                }
            }
        }, 200);
    }

    function handleLiveSessionClosed(data) {
        if (liveSessions[data.session_id]) {
            const session = liveSessions[data.session_id];

            // Mark session as closed
            session.isClosed = true;

            // Collapse if expanded
            if (session.isExpanded) {
                session.isExpanded = false;
                updateLiveFeedEntry(session);
            }

            // Clear auto-collapse timer
            if (session.autoCollapseTimer) {
                clearTimeout(session.autoCollapseTimer);
            }

            // Check if we can remove the arc now or need to wait for minimum display time
            if (session.canRemoveArc) {
                // Minimum display time has passed, remove arc immediately
                removeSessionArc(data.session_id);
            } else {
                // Minimum display time hasn't passed yet, mark for pending removal
                session.pendingRemoval = true;
                // The minDisplayTimer callback will handle removal when time expires
            }

            // Only cleanup old entries if feed is getting too large (100+ entries)
            cleanupOldEntries();
        }
    }

    function cleanupOldEntries() {
        const sessions = Object.values(liveSessions);
        const maxEntries = 100;

        if (sessions.length > maxEntries) {
            // Sort by creation time, oldest first
            const sortedSessions = sessions.sort((a, b) => a.createdAt - b.createdAt);

            // Remove oldest entries beyond the max
            const toRemove = sortedSessions.slice(0, sessions.length - maxEntries);
            toRemove.forEach(session => {
                if (session.feedElement && session.feedElement.parentNode) {
                    session.feedElement.parentNode.removeChild(session.feedElement);
                }
                if (session.arc) {
                    map.removeLayer(session.arc);
                }
                if (session.marker) {
                    map.removeLayer(session.marker);  // Remove canary marker
                }
                if (session.closeTimer) clearTimeout(session.closeTimer);
                if (session.minDisplayTimer) clearTimeout(session.minDisplayTimer);
                if (session.autoCollapseTimer) clearTimeout(session.autoCollapseTimer);

                // Find and delete from liveSessions
                const sessionId = Object.keys(liveSessions).find(
                    id => liveSessions[id] === session
                );
                if (sessionId) {
                    delete liveSessions[sessionId];
                }
            });
        }
    }

    // Control buttons
    document.getElementById('play-pause-btn').addEventListener('click', function() {
        if (animationRunning) {
            // Pausing
            animationRunning = false;
            this.textContent = '‚ñ∂Ô∏è Play';
            if (animationInterval) clearTimeout(animationInterval);
            if (clockInterval) clearInterval(clockInterval);
        } else {
            // Resuming
            animationRunning = true;
            this.textContent = '‚è∏ Pause';

            // Restart clock and animation from current position
            if (lastAttackTimestamp) {
                lastAttackWallTime = Date.now(); // Reset wall time to now
                startReplayClock();
            }

            animateAttacks();
        }
    });

    document.getElementById('reset-btn').addEventListener('click', function() {
        if (animationInterval) clearTimeout(animationInterval);
        if (clockInterval) clearInterval(clockInterval);
        clearMap();
        currentIndex = 0;
        attackFeedCount = 0;
        lastAttackTimestamp = null;
        nextAttackTimestamp = null;
        lastAttackWallTime = null;
        document.getElementById('current-time').textContent = '--';
        document.getElementById('attack-feed').innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px;">Waiting for attacks...</div>';
        if (animationRunning) animateAttacks();
    });

    document.getElementById('speed-slider').addEventListener('input', function() {
        animationSpeed = parseFloat(this.value);
        document.getElementById('speed-text').textContent = `${animationSpeed.toFixed(1)}x`;

        // Reset wall time so speed change takes effect immediately
        if (animationRunning && lastAttackTimestamp) {
            lastAttackWallTime = Date.now();
        }
    });

    document.getElementById('mode-toggle-btn').addEventListener('click', function() {
        if (liveMode) {
            stopLiveMode();
        } else {
            startLiveMode();
        }
    });

    // Fullscreen button
    document.getElementById('fullscreen-btn').addEventListener('click', function() {
        const elem = document.querySelector('.attack-map-page');

        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
            // Enter fullscreen
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { // Safari
                elem.webkitRequestFullscreen();
            } else if (elem.mozRequestFullScreen) { // Firefox
                elem.mozRequestFullScreen();
            } else if (elem.msRequestFullscreen) { // IE/Edge
                elem.msRequestFullscreen();
            }
        } else {
            // Exit fullscreen
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        }
    });

    // Update fullscreen button text when fullscreen state changes
    document.addEventListener('fullscreenchange', updateFullscreenButton);
    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
    document.addEventListener('mozfullscreenchange', updateFullscreenButton);
    document.addEventListener('MSFullscreenChange', updateFullscreenButton);

    function updateFullscreenButton() {
        const btn = document.getElementById('fullscreen-btn');
        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
            btn.textContent = '‚õ∂ Exit Fullscreen';
        } else {
            btn.textContent = '‚õ∂ Fullscreen';
        }
    }

    // Start in live mode by default
    startLiveMode();
});
</script>
{% endblock %}
